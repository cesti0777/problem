package samsung.review;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class P12100 {
	static int testCnt;
	static int answer;
	static int n;
	static int map[][];

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		testCnt = in.nextInt();

		for (int testCase = 1; testCase <= testCnt; testCase++) {
			init();

			n = in.nextInt();

			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) {
					map[i][j] = in.nextInt();
				}
			}

			// print(map);

			execute();

			System.out.println("#" + testCase + " " + answer);
		}
	}

	public static void execute() {
		int curR;
		int curC;

		Queue<Object> q = new LinkedList<Object>();
		q.add(map);
		q.add(1);

		while (!q.isEmpty()) {
			int[][] curMap = (int[][]) q.remove();
			int totalCnt = (int) q.remove();
			int[][] cloneMap;

			System.out.println(111111);
			print(curMap);
			System.out.println(222222);

			if (totalCnt > 5) {
				continue;
			}

			// 상
			cloneMap = curMap.clone();
			print(cloneMap);
			for (int j = 0; j < n; j++) {// 열 순회
				// 합치기
				for (int i = 0; i < n - 1; i++) {// 행 순회
					// 한 행 고정
					curR = i;
					curC = j;
					for (int k = i + 1; k < n; k++) {// 다음 행 탐색
						if (cloneMap[k][curC] != 0) {// 수 발견
							if (cloneMap[curR][curC] == cloneMap[k][curC]) {// 같은
																			// 수
								cloneMap[curR][curC] *= 2;
								cloneMap[k][curC] = 0;
								i = k;
								break;
							}
						}
					}
				}
				// 밀기
				int full = 0;// 현재 빈 인덱스
				int tmp = 0;
				for (int i = 0; i < n; i++) {// 행 순회
					if (cloneMap[i][j] != 0) {// 수 발견
						tmp = cloneMap[i][j];
						cloneMap[i][j] = 0;
						cloneMap[full][j] = tmp;
						full++;
					}
				}
			}
//			print(cloneMap);
			q.add(cloneMap);
			q.add(totalCnt + 1);
			cloneMap = null;

			// 하
			cloneMap = curMap.clone();
			print(cloneMap);
			for (int j = 0; j < n; j++) {// 열 순회
				// 합치기
				for (int i = n - 1; i > 0; i--) {// 행 순회
					// 한 행 고정
					curR = i;
					curC = j;
					for (int k = i - 1; k >= 0; k--) {// 다음 행 탐색
						if (cloneMap[k][curC] != 0) {// 수 발견
							if (cloneMap[curR][curC] == cloneMap[k][curC]) {// 같은
																			// 수
								cloneMap[curR][curC] *= 2;
								cloneMap[k][curC] = 0;
								i = k;
								break;
							}
						}
					}
				}
				// 밀기
				int full = n - 1;// 현재 빈 인덱스
				int tmp = 0;
				for (int i = n - 1; i >= 0; i--) {// 행 순회
					if (cloneMap[i][j] != 0) {// 수 발견
						tmp = cloneMap[i][j];
						cloneMap[i][j] = 0;
						cloneMap[full][j] = tmp;
						full--;
					}
				}
			}
			q.add(cloneMap);
			q.add(totalCnt + 1);
//			print(cloneMap);
			cloneMap = null;

			// 좌
			cloneMap = curMap.clone();
			print(cloneMap);
			for (int i = 0; i < n; i++) {// 행 순회
				// 합치기
				for (int j = 0; j < n - 1; j++) {// 열 순회
					// 한 열 고정
					curR = i;
					curC = j;
					for (int k = j + 1; k < n; k++) {// 다음 열 탐색
						if (cloneMap[curR][k] != 0) {// 수 발견
							if (cloneMap[curR][curC] == cloneMap[curR][k]) {// 같은
																			// 수
								cloneMap[curR][curC] *= 2;
								cloneMap[curR][k] = 0;
								j = k;
								break;
							}
						}
					}
				}
				// 밀기
				int full = 0;// 현재 빈 인덱스
				int tmp = 0;
				for (int j = 0; j < n; j++) {// 열 순회
					if (cloneMap[i][j] != 0) {// 수 발견
						tmp = cloneMap[i][j];
						cloneMap[i][j] = 0;
						cloneMap[i][full] = tmp;
						full++;
					}
				}
			}
			q.add(cloneMap);
			q.add(totalCnt + 1);
//			print(cloneMap);
			cloneMap = null;

			// 우
			cloneMap = curMap.clone();
			print(cloneMap);
			for (int i = 0; i < n; i++) {// 행 순회
				// 합치기
				for (int j = n - 1; j > 0; j--) {// 열 순회
					// 한 열 고정
					curR = i;
					curC = j;
					for (int k = j - 1; k >= 0; k--) {// 다음 열 탐색
						if (cloneMap[curR][k] != 0) {// 수 발견
							if (cloneMap[curR][curC] == cloneMap[curR][k]) {// 같은
																			// 수
								cloneMap[curR][curC] *= 2;
								cloneMap[curR][k] = 0;
								j = k;
								break;
							}
						}
					}
				}
				
				// 밀기
				int full = n - 1;// 현재 빈 인덱스
				int tmp = 0;
				for (int j = n - 1; j >= 0; j--) {// 열 순회
					if (cloneMap[i][j] != 0) {// 수 발견
						tmp = cloneMap[i][j];
						cloneMap[i][j] = 0;
						cloneMap[i][full] = tmp;
						full--;
					}
				}
			}
			q.add(cloneMap);
			q.add(totalCnt + 1);
//			print(cloneMap);
			cloneMap = null;
			
			curMap = null;
			
			

			if (totalCnt == 2) {
				break;
			}

		} // end while

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				answer = Math.max(answer, map[i][j]);
			}
		}
	}

	public static void init() {
		answer = 0;
		n = 0;
		map = null;
		map = new int[20][20];
	}

	public static void print(int[][] arr) {
		System.out.println();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
	public static int[][] cloneMap(int[][] arr){
		int[][] cloneMap = new int[n][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				cloneMap[i][j] = arr[i][j];
			}
		}
		return cloneMap;
	}
}
