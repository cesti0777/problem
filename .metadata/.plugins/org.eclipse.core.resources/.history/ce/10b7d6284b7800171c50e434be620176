//package problem.dfsbfs;
//
//import java.util.Scanner;
//
//public class P2178 {
//	static int n, m, distance;
//	static int[][] map;
//
//	public static void dfs(int curX, int curY, int length) {
//		map[curY][curX] = 0; // 지나온길은 으로
//		if (curY == n && curX == m) { // 최종점이면
//			if (length < distance) {
//				distance = length;
//				System.out.println(distance);
//				return;
//			}
//		}
//		if (curY <= n && map[curY + 1][curX] == 1) { // 아래
//			dfs(curX, curY + 1, length + 1);
//		}
//		if (curX <= m && map[curY][curX + 1] == 1) { // 오른쪽
//			dfs(curX + 1, curY, length + 1);
//		}
//		if (curY >= 1 && map[curY - 1][curX] == 1) { // 위
//			dfs(curX, curY - 1, length + 1);
//		}
//		if (curX >= 1 && map[curY][curX - 1] == 1) { // 왼쪽
//			dfs(curX - 1, curY, length + 1);
//		}
//	}
//
//	public static void main(String[] args) {
//		Scanner in = new Scanner(System.in);
//		try {
//			n = in.nextInt();
//			m = in.nextInt();
//			distance = n * m;
//			map = new int[n + 2][m + 2];
//			// 맵 입력
//			in.nextLine();
//			for (int i = 1; i <= n; i++) {
//				String line = in.nextLine();
//				for (int j = 1; j <= m; j++) {
//					map[i][j] = Character.getNumericValue(line.charAt(j - 1));
//				}
//			}
//
//			dfs(1, 1, 1);
//
//		} finally {
//			in.close();
//			in = null;
//		}
//	}
//
//}
//
//// 예제 입력 복사
//// 4 6
//// 101111
//// 101010
//// 101011
//// 111011
//// 예제 출력 복사
//// 15
//// 예제 입력 2 복사
//// 4 6
//// 110110
//// 110110
//// 111111
//// 111101
//// 예제 출력 2 복사
//// 9

import java.util.Scanner;

public class P2178 {
    static int[][] map; //map을 나타내는 배열 
    static int[][] visited; 
    static int map_size; //map의 Size
    static int min;
    
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        map_size = Integer.parseInt(scan.nextLine().trim()); //map의 size를 입력받는다.
        map = new int[map_size+1][map_size+1]; //map의 배열의 크기를 입력받은 map_size크기로 만든다.
        min = map_size * map_size;
        //이동할 수 있는 path를 입력받기 위해 for문을 사용.
        for(int i = 0; i < map_size; i++) {
            for(int j = 0; j < map_size; j++) {
                map[i][j] = scan.nextInt();
            }
        }
        
        depthfirstSearch(0,0,1);
        
        System.out.println("최단 거리 : " + min);
    }
    
    //dfs알고리즘 시작
    public static void depthfirstSearch(int x, int y, int length) {
        
        if(x == map_size -1 && y == map_size -1){
            if (min > length) min = length;
            return; 
        }
    
        map[y][x] = 0;
            
        //왼쪽으로 이동할 경우
        if(x > 0 && map[y][x-1] == 1) {
            depthfirstSearch(x-1, y, length+1);
        }
            
        //오른쪽으로 이동할 경우
        if(x < map_size && map[y][x+1] == 1) {
            depthfirstSearch(x+1, y, length+1);
        }
        //아래로 이동할 경우
        if(y < map_size && map[y+1][x] == 1) {
            depthfirstSearch(x, y+1, length+1);
        }
        //위로 이동할 경우
        if(y > 0 && map[y-1][x] == 1) {
            depthfirstSearch(x, y-1, length+1);
        }
        
        map[y][x] = 1;
    }
}


