package samsung.practice1;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class P12786 {
	static int n;
	static int k;
	static int holeCnt;
	static int holeHight;
	static int[][] map = new int[20][200];
	static boolean[][] visited = new boolean[20][200];
	static int min = 51;

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		n = in.nextInt();
		k = in.nextInt();

		// 맵 입력
		for (int j = 1; j < n * 2; j += 2) {
			holeCnt = in.nextInt();
			// 나무 세우기
			for (int i = 0; i < 20; i++) {
				map[i][j] = 1;
			}
			// 구멍 뚫기
			for (int i = 0; i < holeCnt; i++) {
				holeHight = in.nextInt();
				map[holeHight - 1][j] = 0;
			}
		}
//		print(map);

		Queue<Integer> q = new LinkedList<Integer>();

		q.add(0);
		q.add(0);
		q.add(1);
		q.add(k);
		q.add(0);

		while (!q.isEmpty()) {
			int mC = q.remove();
			int mR = q.remove();
			int curTree = q.remove();
			int curK = q.remove();
			int useT = q.remove();
			int no = 0;

			if (curTree > n) {
				min = Math.min(min, useT);
				continue;
			}

			// O(제자리)
			System.out.println("curTree : " + curTree);
			System.out.println((mC + 1) +" "+ mR);
			if (visited[mR][mC + 1] != true && map[mR][mC + 1] == 0) {
				map[mR][mC + 1] = 1;
				q.add(mC + 2);
				q.add(mR);
				q.add(curTree + 1);
				q.add(curK);
				q.add(useT);
			} else {
				no++;
			}
			// A(위로 1)
			System.out.println((mC + 1) +" "+ (mR + 1));
			if (mR + 1 < 20 && visited[mR + 1][mC + 1] != true && map[mR + 1][mC + 1] == 0) {
				map[mR + 1][mC + 1] = 1;
				q.add(mC + 2);
				q.add(mR + 1);
				q.add(curTree + 1);
				q.add(curK);
				q.add(useT);
			} else {
				no++;
			}
			// B(위로 2x현재높이, 최대 20)
			System.out.println((mC + 1) +" "+ (mR + mR + 1));
			if (mR + mR + 1 >= 20) {
				if (visited[19][mC + 1] != true && map[19][mC + 1] == 0) {
					visited[19][mC + 1] = true;
					q.add(mC + 2);
					q.add(19);
					q.add(curTree + 1);
					q.add(curK);
					q.add(useT);
				}
			} else if (visited[mR + mR + 1][mC + 1] != true && map[mR + mR + 1][mC + 1] == 0) {
				map[mR + mR + 1][mC + 1] = 1;
				q.add(mC + 2);
				q.add(mR + mR + 1);
				q.add(curTree + 1);
				q.add(curK);
				q.add(useT);
			} else {
				no++;
			}
			// C(아래로 1)
			System.out.println((mC + 1) + " " + (mR - 1));
			if (mR - 1 >= 0 && visited[mR - 1][mC + 1] != true && map[mR - 1][mC + 1] == 0) {
				map[mR - 1][mC + 1] = 1;
				q.add(mC + 2);
				q.add(mR - 1);
				q.add(curTree + 1);
				q.add(curK);
				q.add(useT);
			} else {
				no++;
			}
			// T(순간이동, 4가지 안되면 사용)
			System.out.println((mC + 1) +" "+ mR);
			if (curK > 0) {
				if (no == 4) {
					for (int i = 0; i < 20; i++) {
						if (visited[i][mC + 1] != true && map[i][mC + 1] == 0) {
							map[i][mC + 1] = 1;
							q.add(mC + 2);
							q.add(i);
							q.add(curTree + 1);
							q.add(curK - 1);
							q.add(useT + 1);
						}
					}
				}
			}
		} // end while

		// 최종 출력
		if (min == 51) {
			System.out.println(-1);
		} else {
			System.out.println(min);
		}
	}

	public static void print(int[][] arr) {
		for (int i = 0; i < 20; i++) {
			for (int j = 0; j < 2 * n; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}

	public static class Location {
		int mC;
		int mR;
		int curTree;
		int k;
		int useT;

		public Location() {
		}

		public Location(int mC, int mR, int curTree, int k, int useT) {
			super();
			this.mC = mC;
			this.mR = mR;
			this.curTree = curTree;
			this.k = k;
			this.useT = useT;
		}
	}
}

//30
//50
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
//10 1 2 4 6 7 12 14 15 17 20
//10 2 4 6 7 9 12 15 18 19 20
