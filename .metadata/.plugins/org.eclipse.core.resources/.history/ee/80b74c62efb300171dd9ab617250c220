package samsung.practice1;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class P13460_new {
	static int y;
	static int x;
	static char map[][] = new char[10][10];
	static boolean[][][][] visited = new boolean[10][10][10][10];
	static int rY, rX, bY, bX;
	static int[] dY = { -1, 1, 0, 0 };
	static int[] dX = { 0, 0, -1, 1 };

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		y = in.nextInt();
		x = in.nextInt();
		in.nextLine();

		for (int i = 0; i < y; i++) {
			String line = in.nextLine();
			for (int j = 0; j < x; j++) {
				map[i][j] = line.charAt(j);
				if (map[i][j] == 'R') {
					rY = i;
					rX = j;
				} else if (map[i][j] == 'B') {
					bY = i;
					bX = j;
				}
			}
		}

		Queue<Data> q = new LinkedList<Data>();
		q.add(new Data(rY, rX, bY, bX, 0));
		visited[rY][rX][bY][bX] = true;
		while (!q.isEmpty()) {
			Data d = q.remove();

			for (int i = 0; i < 4; i++) {
				int rCurY = d.rY;
				int rCurX = d.rX;
				int bCurY = d.bY;
				int bCurX = d.bX;
				boolean rGole = false;
				boolean bGole = false;

				// R 굴리기, 공 겹치는 경우 고려 x
				while (true) {
					rCurY += dY[i];
					rCurX += dX[i];

					if (map[rCurY][rCurX] == '#') {// 벽이면 이전 좌표로 복귀하고 그만
						rCurY -= dY[i];
						rCurX -= dX[i];
						break;
					} else if (map[rCurY][rCurX] == 'O') {// 골이면 flag 바꾸고 그만 굴려
						rGole = true;
						break;
					}
				}

				// B 굴리기, 공 겹치는 경우 고려 x
				while (true) {
					bCurX += dX[i];
					bCurY += dY[i];

					if (map[bCurY][bCurX] == '#') {// 벽이면 이전 좌표로 복귀하고 그만
						bCurY -= dY[i];
						bCurX -= dX[i];
						break;
					} else if (map[bCurY][bCurX] == 'O') {// 골이면 flag 바꾸고 그만 굴려
						bGole = true;
						break;
					}
				}

				// B 골
				if (bGole == true) {
					continue;
				}

				// A 골
				if (rGole == true) {
					if (d.cnt + 1 <= 10) {
						System.out.println(d.cnt + 1);
						return;
					} else {
						System.out.println(-1);
						return;
					}
				}

				// R, B 모두 골이 아니고 같은 위치에 존재할 때
				if (rCurX == bCurX && rCurY == bCurY) {
					// 원래 파란구슬이랑 빨간 구슬이 같은 x좌표에 있는 상태인데
					if (d.bY == d.rY) {
						// 오른쪽 방향으로 움직였던 경우
						if (i == 3) {
							// 원래 R B 위치였다면
							if (d.bX > d.rX) {
								rCurX = rCurX - dX[i]; // R구슬을 한칸 이전으로 옮기기
							}
							// 원래 B R 위치였다면
							else if (d.bX < d.rX) {
								bCurX = bCurX - dX[i]; // B구슬을 한칸 이전으로 옮기기
							}
						}
						// 왼쪽 방향으로 움직였던 경우
						else if (i == 2) {
							// 원래 R B 위치였다면
							if (d.bX > d.rX)
								bCurX = bCurX - dX[i]; // B구슬을 한칸 이전으로
							// 원래 B R 위치였다면
							else if (d.bX < d.rX)
								rCurX = rCurX - dX[i]; // R구슬을 한칸 이전으로
						}
					}
					// 원래 파란구슬과 빨간 구슬이 같은 y좌표에 있는 상태였으면
					else if (d.bX == d.rX) {
						// 위로 움직였던 경우
						if (i == 0) {
							/*
							 * 원래 R B 였으면
							 */
							if (d.bY > d.rY)
								bCurY = bCurY - dY[i]; // B구슬을 한칸 밑으로
							/*
							 * 원래 B R 였으면
							 */
							else if (d.bY < d.rY)
								rCurY = rCurY - dY[i]; // R구슬을 한칸 밑으로
						}
						// 아래로 움직였던 경우
						else if (i == 1) {
							/*
							 * 원래 R B 였으면
							 */
							if (d.bY > d.rY)
								rCurY = rCurY - dY[i]; // R구슬을 한칸 위로
							/*
							 * 원래 B R 였으면
							 */
							else if (d.bY < d.rY)
								bCurY = bCurY - dY[i]; // B구슬을 한칸 위로
						}
					}
				}

				if (visited[rCurY][rCurX][bCurY][bCurX] != true) {
					visited[rCurY][rCurX][bCurY][bCurX] = true;
					q.add(new Data(rCurY, rCurX, bCurY, bCurX, d.cnt + 1));
				}
			}
		}
		System.out.println(-1);
	}

	public static void print(char[][] arr) {
		System.out.println();
		for (int i = 0; i < y; i++) {
			for (int j = 0; j < x; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}

	public static class Data {
		int rY, rX, bY, bX, cnt;

		public Data() {
		}

		public Data(int rY, int rX, int bY, int bX, int cnt) {
			this.rY = rY;
			this.rX = rX;
			this.bY = bY;
			this.bX = bX;
			this.cnt = cnt;
		}
	}
}
